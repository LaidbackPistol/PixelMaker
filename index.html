<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Pixel Art Tool with Layers</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: rgb(36, 36, 36);
            color: white;
        }

        /* Add new styles for drag and drop */
        .layer-item {
            display: flex;
            align-items: center;
            padding: 5px;
            margin: 2px 0;
            background-color: #444;
            border-radius: 3px;
            gap: 10px;
            cursor: move; /* Show move cursor */
            user-select: none; /* Prevent text selection while dragging */
        }

        .layer-item.dragging {
            opacity: 0.5;
            background-color: #666;
        }

        .layer-item.drag-over {
            border-top: 2px solid #fff;
        }

        /* Add grab handle */
        .layer-handle {
            cursor: move;
            padding: 0 5px;
            color: #888;
        }

        .layer-item:hover .layer-handle {
            color: #fff;
        }

        .tool-group {
            display: flex;
            gap: 5px;
            margin-right: 10px;
        }

        .tool-button {
            background-color: #444;
            color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
        }

        .tool-button.selected {
            background-color: #666;
        }

        .selected-pixel {
            outline: 1px solid rgba(255, 255, 255, 0.5);
        }

        #toolbar {
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #colorPalette {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .palette-color {
            width: 30px;
            height: 30px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }

        .palette-color.selected {
            border-color: white;
        }

        .eraser-tile {
            width: 30px;
            height: 30px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
            background-image: 
                linear-gradient(45deg, #808080 25%, transparent 25%),
                linear-gradient(-45deg, #808080 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #808080 75%),
                linear-gradient(-45deg, transparent 75%, #808080 75%);
            background-size: 10px 10px;
            background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
            background-color: white;
        }

        .eraser-tile.selected {
            border-color: white;
        }

        #svgCanvasContainer {
            position: relative;
            width: 500px;
            height: 500px;
            overflow: hidden; /* Add this to contain the selection overlay */
        }

        #svgCanvasContainer::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            touch-action: none;
        }

        #svgCanvasContainer::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            border: 0px solid rgba(36, 36, 36, 0.5);
            box-shadow: inset 0 0 20px 20px rgb(36, 36, 36);
        }

        .svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #selectionOverlay {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px dashed white;
            pointer-events: none;
            z-index: 1000;
            box-sizing: border-box;
            transform-origin: top left;
        }

        #importInput, #paletteColorInput, #importPaletteInput {
            display: none;
        }

        .button-group {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        button {
            background-color: #444;
            color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
        }

        button:disabled {
            background-color: #333;
            color: #666;
            cursor: not-allowed;
        }

        #layerPanel {
            width: 500px;
            margin-top: 20px;
            background-color: #333;
            padding: 10px;
            border-radius: 4px;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 5px;
            margin: 2px 0;
            background-color: #444;
            border-radius: 3px;
            gap: 10px;
        }

        .layer-item.selected {
            background-color: #555;
            border: 1px solid #666;
        }

        .layer-visibility {
            cursor: pointer;
            padding: 2px;
        }

        /* Replace or add these styles */
        .layer-name-button {
            flex-grow: 1;
            text-align: left;
            background: none;
            border: none;
            color: white;
            padding: 4px 8px;
            cursor: pointer;
            margin: 0;
            font-size: inherit;
            font-family: inherit;
        }

        .layer-name-button:hover {
            background-color: #555;
        }

        .layer-name-input {
            flex-grow: 1;
            background-color: #555;
            color: white;
            border: 1px solid #666;
            padding: 3px 7px;
            margin: 0;
            font-family: inherit;
            font-size: inherit;
        }

        .layer-controls {
            display: flex;
            gap: 5px;
        }

        #addLayerButton {
            width: 100%;
            margin-top: 5px;
        }

        .modifier-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }

        .modifier-control:hover {
            background-color: #3a3a3a;
        }

        /* Add groups for related controls */
        .modifier-group {
            border-bottom: 1px solid #444;
            margin-bottom: 8px;
            padding-bottom: 8px;
        }

        .modifier-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .panning {
            cursor: move !important; /* Show move cursor while panning */
        }
    </style>
</head>
<body>
    <div id="colorPalette"></div>
    <input type="color" id="paletteColorInput" />
    <input type="file" id="importPaletteInput" accept=".svg" />

    <div class="button-group">
        <button id="resetPaletteButton">Reset Palette</button>
        <button id="exportPaletteButton">Export Palette</button>
        <button id="importPaletteButton">Import Palette</button>
    </div>

    <div id="toolbar">
        <div class="tool-group">
            <button id="pencilTool" class="tool-button selected">‚úèÔ∏è Pencil</button>
            <button id="selectTool" class="tool-button">‚óªÔ∏è Select</button>
        </div>
        <button id="exportSVGBtn">Export SVG</button>
        <button id="importSVGBtn">Import SVG</button>
        <input type="file" id="importInput" accept=".svg" />
    </div>

    <div class="button-group">
        <button id="undoButton" disabled>Undo</button>
        <button id="redoButton" disabled>Redo</button>
    </div>

    <div id="svgCanvasContainer">
        <!-- SVG layers will be dynamically added here -->
        <div id="selectionOverlay" style="display: none; position: absolute; border: 1px dashed white; pointer-events: none;"></div>
    </div>

    <div id="layerPanel">
        <div id="layerList"></div>
        <button id="addLayerButton">Add Layer</button>
    </div>

    <div id="modifierControls">
        <div class="modifier-group">
            <div class="modifier-control">
                <label for="bendSlider">Edge Bend:</label>
                <input type="range" id="bendSlider" class="modifier-slider" min="-5" max="5" value="0" step="0.1">
                <span id="bendValue" class="modifier-value">0.0</span>
            </div>
        </div>
        <div class="modifier-group">
            <div class="modifier-control">
                <label for="scaleSlider">Pixel Scale:</label>
                <input type="range" id="scaleSlider" class="modifier-slider" min="0.1" max="2" value="1" step="0.1">
                <span id="scaleValue" class="modifier-value">1.0</span>
            </div>
        </div>
        <div class="modifier-group">
            <div class="modifier-control">
                <label for="blurXSlider">Blur X:</label>
                <input type="range" id="blurXSlider" class="modifier-slider" min="0" max="20" value="0" step="0.1">
                <span id="blurXValue" class="modifier-value">0.0</span>
            </div>
            <div class="modifier-control">
                <label for="blurYSlider">Blur Y:</label>
                <input type="range" id="blurYSlider" class="modifier-slider" min="0" max="20" value="0" step="0.1">
                <span id="blurYValue" class="modifier-value">0.0</span>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let viewportOffsetX = 0;
        let viewportOffsetY = 0;
        let isPanning = false;
        let lastPanX = 0;
        let lastPanY = 0;
        let gridSize = 20;
        let currentColor = "#000000";
        let isDrawing = false;
        let selectedPaletteIndex = 0;
        let lastDrawnPixel = null;
        let hasDrawnPixel = false;
        let bendAmount = 0;
        let blurXAmount = 0;
        let blurYAmount = 0;
        let lastTouchDistance = 0;
        let isPanningMobile = false;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let currentTool = 'pencil';
        let isSelecting = false;
        let selectionStart = null;
        let selectionEnd = null;
        let selectedPixels = new Set();
        let isDraggingSelection = false;
        let dragOffset = { x: 0, y: 0 };
        let originalPositions = new Map();
        let panningCursor = null;
        let clipboardData = null;
        let clipboardOffset = null;
        let pixelScale = 1.0;

        // History management
        const MAX_HISTORY = 30;
        let history = [];
        let currentHistoryIndex = -1;
        let isUndoRedoAction = false;

        // Layer management
        const MAX_LAYERS = 5;
        let layers = [];
        let activeLayer = null;
        let activeLayerId = null;
        let nextLayerId = 1; // Global counter for unique layer IDs

        // Default color palette
        const defaultPalette = [
            "#000000",
            "#124559",
            "#598392",
            "#aec3b0",
            "#ffffff"
        ];
        let palette = [...defaultPalette];

        // DOM Elements
        const colorPalette = document.getElementById("colorPalette");
        const paletteColorInput = document.getElementById("paletteColorInput");
        const importPaletteInput = document.getElementById("importPaletteInput");
        const resetPaletteButton = document.getElementById("resetPaletteButton");
        const exportPaletteButton = document.getElementById("exportPaletteButton");
        const importPaletteButton = document.getElementById("importPaletteButton");
        const undoButton = document.getElementById("undoButton");
        const redoButton = document.getElementById("redoButton");
        const importInput = document.getElementById("importInput");
        const layerPanel = document.getElementById("layerPanel");
        const layerList = document.getElementById("layerList");
        const addLayerButton = document.getElementById("addLayerButton");
        const svgCanvasContainer = document.getElementById("svgCanvasContainer");
        // Get new control elements
        const blurXSlider = document.getElementById('blurXSlider');
        const blurYSlider = document.getElementById('blurYSlider');
        const blurXValue = document.getElementById('blurXValue');
        const blurYValue = document.getElementById('blurYValue');
        // Add tool selection handlers
        const pencilToolBtn = document.getElementById('pencilTool');
        const selectToolBtn = document.getElementById('selectTool');
        const selectionOverlay = document.getElementById('selectionOverlay');
        const scaleSlider = document.getElementById('scaleSlider');
        const scaleValue = document.getElementById('scaleValue');

        // Updated Layer class
        class Layer {
            constructor() {
                this.id = nextLayerId++;
                this.name = this.generateUniqueName();
                this.visible = true;
                this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                this.svg.setAttribute("class", "svg-layer");
                this.svg.setAttribute("width", "500");
                this.svg.setAttribute("height", "500");
            }

            generateUniqueName() {
                let baseName = `Layer ${this.id}`;
                let name = baseName;
                let counter = 1;
                
                // Keep incrementing until we find a unique name
                while (layers.some(layer => layer.name === name)) {
                    name = `${baseName} (${counter})`;
                    counter++;
                }
                return name;
            }
        }

        // Convert screen coordinates to grid coordinates
        function screenToGridCoordinates(screenX, screenY) {
            const rect = activeLayer.getBoundingClientRect();
            return {
                x: Math.floor((screenX - rect.left + viewportOffsetX) / gridSize) * gridSize,
                y: Math.floor((screenY - rect.top + viewportOffsetY) / gridSize) * gridSize
            };
        }

        // Convert grid coordinates to screen coordinates
        function gridToScreenCoordinates(gridX, gridY) {
            return {
                x: gridX - viewportOffsetX,
                y: gridY - viewportOffsetY
            };
        }

        // Initialize color palette
        function initializePalette() {
            colorPalette.innerHTML = '';
            
            const eraserTile = document.createElement('div');
            eraserTile.className = 'eraser-tile';
            eraserTile.setAttribute('data-index', 'eraser');
            
            eraserTile.addEventListener('click', () => {
                document.querySelectorAll('.palette-color, .eraser-tile').forEach(el => {
                    el.classList.remove('selected');
                });
                eraserTile.classList.add('selected');
                currentColor = null;
            });
            
            colorPalette.appendChild(eraserTile);

            palette.forEach((color, index) => {
                const paletteColor = document.createElement('div');
                paletteColor.className = 'palette-color';
                paletteColor.style.backgroundColor = color;
                paletteColor.setAttribute('data-index', index);
                
                if (index === 0) {
                    paletteColor.classList.add('selected');
                }

                paletteColor.addEventListener('click', () => {
                    document.querySelectorAll('.palette-color, .eraser-tile').forEach(el => {
                        el.classList.remove('selected');
                    });
                    
                    paletteColor.classList.add('selected');
                    currentColor = paletteColor.style.backgroundColor;
                    selectedPaletteIndex = index;
                });

                paletteColor.addEventListener('dblclick', () => {
                    paletteColorInput.value = color;
                    paletteColorInput.setAttribute('data-index', index);
                    paletteColorInput.click();
                });

                colorPalette.appendChild(paletteColor);
            });
        }

        function exportPalette() {
            // Create SVG with palette data
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("width", "0");
            svg.setAttribute("height", "0");
            
            // Add palette data as metadata
            const metadata = document.createElementNS("http://www.w3.org/2000/svg", "metadata");
            metadata.textContent = JSON.stringify(palette);
            svg.appendChild(metadata);
            
            // Create and trigger download
            const serializer = new XMLSerializer();
            const svgBlob = new Blob([serializer.serializeToString(svg)], { type: "image/svg+xml" });
            const url = URL.createObjectURL(svgBlob);
            
            const link = document.createElement("a");
            link.href = url;
            link.download = "palette.svg";
            link.click();
            
            URL.revokeObjectURL(url);
        }

        exportPaletteButton.addEventListener('click', exportPalette);

        function initializeLayers() {
            createLayer();
            updateAddLayerButton();
            renderLayerPanel();
        }

        function createLayer() {
            if (layers.length >= MAX_LAYERS) return;

            const newLayer = new Layer();
            layers.push(newLayer);
            svgCanvasContainer.appendChild(newLayer.svg);
            
            // Always set the new layer as active
            setActiveLayer(newLayer.id);

            updateAddLayerButton();
            renderLayerPanel();
            saveState();
            return newLayer;
        }

        function deleteLayer(layerId) {
            const index = layers.findIndex(l => l.id === layerId);
            if (index === -1) return;

            const layer = layers[index];
            svgCanvasContainer.removeChild(layer.svg);
            layers.splice(index, 1);

            if (activeLayerId === layerId) {
                setActiveLayer(layers[layers.length - 1]?.id);
            }

            updateAddLayerButton();
            renderLayerPanel();
            saveState(); // Save state after deleting layer
        }

        function setActiveLayer(layerId) {
            activeLayerId = layerId;
            activeLayer = layers.find(l => l.id === layerId)?.svg;
            renderLayerPanel();
        }

        function toggleLayerVisibility(layerId) {
            const layer = layers.find(l => l.id === layerId);
            if (layer) {
                layer.visible = !layer.visible;
                layer.svg.style.display = layer.visible ? 'block' : 'none';
                renderLayerPanel();
                saveState(); // Save state after toggling visibility
            }
        }

        function renderLayerPanel() {
            layerList.innerHTML = '';
            
            layers.slice().reverse().forEach(layer => {
                const layerItem = document.createElement('div');
                layerItem.className = `layer-item ${layer.id === activeLayerId ? 'selected' : ''}`;
                layerItem.setAttribute('data-layer-id', layer.id);
                
                // Add drag handle
                const handle = document.createElement('span');
                handle.className = 'layer-handle';
                handle.innerHTML = '‚ãÆ‚ãÆ'; // Double vertical dots as drag handle
                
                // Visibility toggle
                const visibility = document.createElement('span');
                visibility.className = 'layer-visibility';
                visibility.innerHTML = layer.visible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è';
                visibility.onclick = (e) => {
                    e.stopPropagation();
                    toggleLayerVisibility(layer.id);
                };

                // Create name button
                const nameButton = document.createElement('button');
                nameButton.className = 'layer-name-button';
                nameButton.textContent = layer.name;
                nameButton.addEventListener('click', () => setActiveLayer(layer.id));

                // Handle double click to edit
                nameButton.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = layer.name;
                    input.className = 'layer-name-input';

                    nameButton.replaceWith(input);
                    input.focus();
                    input.select();

                    function saveNewName() {
                        const newName = input.value.trim();
                        if (newName && newName !== layer.name) {
                            if (layers.some(l => l.id !== layer.id && l.name === newName)) {
                                alert('A layer with this name already exists. Please choose a different name.');
                                return;
                            }
                            layer.name = newName;
                            saveState();
                        }
                        renderLayerPanel();
                    }

                    input.addEventListener('blur', saveNewName);
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            saveNewName();
                        } else if (e.key === 'Escape') {
                            renderLayerPanel();
                        }
                    });
                });

                // Controls
                const controls = document.createElement('div');
                controls.className = 'layer-controls';

                if (layers.length > 1) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'üóëÔ∏è';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteLayer(layer.id);
                    };
                    controls.appendChild(deleteBtn);
                }

                // Add drag and drop event listeners
                layerItem.draggable = true;
                
                layerItem.addEventListener('dragstart', (e) => {
                    e.stopPropagation();
                    layerItem.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', layer.id);
                });

                layerItem.addEventListener('dragend', (e) => {
                    e.stopPropagation();
                    layerItem.classList.remove('dragging');
                    document.querySelectorAll('.layer-item').forEach(item => {
                        item.classList.remove('drag-over');
                    });
                });

                layerItem.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    layerItem.classList.add('drag-over');
                });

                layerItem.addEventListener('dragleave', (e) => {
                    e.stopPropagation();
                    layerItem.classList.remove('drag-over');
                });

                layerItem.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
                    const targetId = parseInt(layerItem.getAttribute('data-layer-id'));
                    
                    if (draggedId !== targetId) {
                        reorderLayers(draggedId, targetId);
                    }
                    
                    layerItem.classList.remove('drag-over');
                });

                // Append everything in the correct order
                layerItem.appendChild(handle);
                layerItem.appendChild(visibility);
                layerItem.appendChild(nameButton);
                layerItem.appendChild(controls);
                layerList.appendChild(layerItem);
            });
        }

        function reorderLayers(draggedId, targetId) {
            const draggedIndex = layers.findIndex(l => l.id === draggedId);
            const targetIndex = layers.findIndex(l => l.id === targetId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            // Remove dragged layer from array
            const [draggedLayer] = layers.splice(draggedIndex, 1);
            
            // Insert at new position
            layers.splice(targetIndex, 0, draggedLayer);
            
            // Update SVG order in the DOM
            layers.forEach((layer, index) => {
                svgCanvasContainer.appendChild(layer.svg);
            });
            
            saveState();
            renderLayerPanel();
        }

        function updateAddLayerButton() {
            addLayerButton.disabled = layers.length >= MAX_LAYERS;
        }

        function getTouchPosition(e) {
            if (!activeLayer) return null;
            
            const touch = e.touches[0];
            const rect = activeLayer.getBoundingClientRect();
            return screenToGridCoordinates(touch.clientX, touch.clientY);
        }

        function updateFilters(svg) {
            const existingDefs = svg.querySelector('defs');
            if (existingDefs) {
                svg.removeChild(existingDefs);
            }

            const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            
            // Create main filter
            const mainFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
            mainFilter.setAttribute("id", "mainEffect");
            // Extend the filter region to prevent clipping
            mainFilter.setAttribute("x", "-100%");
            mainFilter.setAttribute("y", "-100%");
            mainFilter.setAttribute("width", "300%");
            mainFilter.setAttribute("height", "300%");
            
            // Add directional blur
            const blurEffect = document.createElementNS("http://www.w3.org/2000/svg", "feGaussianBlur");
            blurEffect.setAttribute("in", "SourceGraphic");
            blurEffect.setAttribute("stdDeviation", `${blurXAmount} ${blurYAmount}`);
            mainFilter.appendChild(blurEffect);
            
            defs.appendChild(mainFilter);
            svg.insertBefore(defs, svg.firstChild);

            // Apply filter directly to the SVG element instead of individual paths
            if (blurXAmount > 0 || blurYAmount > 0) {
                svg.setAttribute('filter', 'url(#mainEffect)');
            } else {
                svg.removeAttribute('filter');
            }
        }

        function createPixelPath(gridX, gridY, color) {
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("fill", color);
            updatePixelPath(path, gridX, gridY);
            return path;
        }

        function updatePixelPath(path, gridX, gridY) {
            const screenPos = gridToScreenCoordinates(gridX, gridY);
            const size = gridSize * pixelScale;
            const bend = bendAmount;
            
            // Calculate control points for the curves
            const cp = Math.abs(bend);
            const sign = Math.sign(bend);
            
            // Calculate offset to keep pixel centered in grid cell
            const offset = (gridSize - size) / 2;
            
            // Create path with curved edges using screen coordinates
            let d = [
                `M ${screenPos.x + offset} ${screenPos.y + offset}`,
                
                // Top edge (curved)
                `C ${screenPos.x + offset + cp} ${screenPos.y + offset - sign * cp}, 
                ${screenPos.x + offset + size - cp} ${screenPos.y + offset - sign * cp}, 
                ${screenPos.x + offset + size} ${screenPos.y + offset}`,
                
                // Right edge (curved)
                `C ${screenPos.x + offset + size + sign * cp} ${screenPos.y + offset + cp}, 
                ${screenPos.x + offset + size + sign * cp} ${screenPos.y + offset + size - cp}, 
                ${screenPos.x + offset + size} ${screenPos.y + offset + size}`,
                
                // Bottom edge (curved)
                `C ${screenPos.x + offset + size - cp} ${screenPos.y + offset + size + sign * cp}, 
                ${screenPos.x + offset + cp} ${screenPos.y + offset + size + sign * cp}, 
                ${screenPos.x + offset} ${screenPos.y + offset + size}`,
                
                // Left edge (curved)
                `C ${screenPos.x + offset - sign * cp} ${screenPos.y + offset + size - cp}, 
                ${screenPos.x + offset - sign * cp} ${screenPos.y + offset + cp}, 
                ${screenPos.x + offset} ${screenPos.y + offset}`,
                
                'Z'
            ].join(' ');
            
            path.setAttribute('d', d);
        }

        function updateSelectionOverlay() {
            if (!selectionStart || !selectionEnd) return;

            // Get the container's position
            const containerRect = svgCanvasContainer.getBoundingClientRect();
            
            // Calculate relative positions within the container
            const startX = selectionStart.x;
            const startY = selectionStart.y;
            const endX = selectionEnd.x;
            const endY = selectionEnd.y;
            
            // Convert to grid coordinates
            const gridStart = screenToGridCoordinates(startX + containerRect.left, startY + containerRect.top);
            const gridEnd = screenToGridCoordinates(endX + containerRect.left, endY + containerRect.top);
            
            // Convert back to screen coordinates
            const screenStart = gridToScreenCoordinates(gridStart.x, gridStart.y);
            const screenEnd = gridToScreenCoordinates(gridEnd.x + gridSize, gridEnd.y + gridSize);
            
            // Position the overlay relative to the container
            selectionOverlay.style.position = 'absolute';
            selectionOverlay.style.left = `${Math.min(screenStart.x, screenEnd.x)}px`;
            selectionOverlay.style.top = `${Math.min(screenStart.y, screenEnd.y)}px`;
            selectionOverlay.style.width = `${Math.abs(screenEnd.x - screenStart.x)}px`;
            selectionOverlay.style.height = `${Math.abs(screenEnd.y - screenStart.y)}px`;
        }

        function updateSelection() {
            if (!activeLayer || !selectionStart || !selectionEnd) return;

            // Get the actual selection overlay position and size
            const rect = svgCanvasContainer.getBoundingClientRect();
            const overlayRect = selectionOverlay.getBoundingClientRect();

            // Calculate relative positions to the container
            const overlayStart = {
                x: overlayRect.left - rect.left,
                y: overlayRect.top - rect.top
            };

            const overlayEnd = {
                x: overlayStart.x + overlayRect.width - 1,
                y: overlayStart.y + overlayRect.height - 1
            };

            // Convert to grid coordinates
            const gridStart = screenToGridCoordinates(overlayStart.x + rect.left, overlayStart.y + rect.top);
            const gridEnd = screenToGridCoordinates(overlayEnd.x + rect.left, overlayEnd.y + rect.top);

            // Make sure we include all pixels within the selection bounds
            const minX = Math.min(gridStart.x, gridEnd.x);
            const maxX = Math.max(gridStart.x, gridEnd.x);
            const minY = Math.min(gridStart.y, gridEnd.y);
            const maxY = Math.max(gridStart.y, gridEnd.y);

            selectedPixels.clear();
            Array.from(activeLayer.children).forEach(pixel => {
                if (pixel.tagName.toLowerCase() === 'path') {
                    const x = parseInt(pixel.getAttribute('data-x'));
                    const y = parseInt(pixel.getAttribute('data-y'));

                    // Check if pixel is within the selection bounds
                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                        selectedPixels.add(pixel);
                        pixel.classList.add('selected-pixel');
                    } else {
                        pixel.classList.remove('selected-pixel');
                    }
                }
            });

            // Reset selection coordinates after applying the selection
            selectionStart = null;
            selectionEnd = null;
        }

        function clearSelection() {
            selectedPixels.forEach(pixel => {
                if (pixel && pixel.classList) {
                    pixel.classList.remove('selected-pixel');
                }
            });
            selectedPixels.clear();
            originalPositions.clear();
            selectionStart = null;
            selectionEnd = null;
            selectionOverlay.style.display = 'none';
            
            // Ensure the selection overlay is reset
            const overlay = document.getElementById('selectionOverlay');
            if (overlay) {
                overlay.style.width = '0';
                overlay.style.height = '0';
                overlay.style.display = 'none';
            }
        }

        function isPixelInSelection(clientX, clientY) {
            const gridPos = screenToGridCoordinates(clientX, clientY);
            return Array.from(selectedPixels).some(pixel => {
                const pixelX = parseInt(pixel.getAttribute('data-x'));
                const pixelY = parseInt(pixel.getAttribute('data-y'));
                return pixelX === gridPos.x && pixelY === gridPos.y;
            });
        }

        function handlePanning(e) {
            if (!isPanning) {
                isPanning = true;
                lastPanX = e.clientX;
                lastPanY = e.clientY;
                        
                // Just add the panning class without creating additional cursor
                document.body.classList.add('panning');
                return true;
            }
                    
            const deltaX = e.clientX - lastPanX;
            const deltaY = e.clientY - lastPanY;
                    
            viewportOffsetX -= deltaX;
            viewportOffsetY -= deltaY;
                    
            lastPanX = e.clientX;
            lastPanY = e.clientY;
                    
            updateAllPixels();
            updateGridPosition();
            return true;
        }

        function cleanupPanning() {
            if (isPanning) {
                document.body.classList.remove('panning');
            }
            isPanning = false;
        }

        bendSlider.addEventListener('input', (e) => {
            bendAmount = parseFloat(e.target.value);
            bendValue.textContent = bendAmount.toFixed(1);
            updateAllPixels();
        });

        blurXSlider.addEventListener('input', (e) => {
            blurXAmount = parseFloat(e.target.value);
            blurXValue.textContent = blurXAmount.toFixed(1);
            layers.forEach(layer => {
                updateFilters(layer.svg);
            });
        });

        blurYSlider.addEventListener('input', (e) => {
            blurYAmount = parseFloat(e.target.value);
            blurYValue.textContent = blurYAmount.toFixed(1);
            layers.forEach(layer => {
                updateFilters(layer.svg);
            });
        });

        // Modify create layer function to include filters
        const originalCreateLayer = createLayer;
        
        function updateAllPixels() {
            layers.forEach(layer => {
                Array.from(layer.svg.children).forEach(pixel => {
                    if (pixel.tagName.toLowerCase() === 'path') {
                        const gridX = parseInt(pixel.getAttribute('data-x'));
                        const gridY = parseInt(pixel.getAttribute('data-y'));
                        updatePixelPath(pixel, gridX, gridY);
                    }
                });
            });
        }

        // Modify drawPixelAtPosition to use paths instead of rectangles
        function drawPixelAtPosition(position) {
            if (!position || !activeLayer) return;
            
            const { x, y } = position;
            
            if (lastDrawnPixel && lastDrawnPixel.x === x && lastDrawnPixel.y === y) {
                return;
            }
            
            const existingPixel = Array.from(activeLayer.children).find(element => {
                return parseInt(element.getAttribute("data-x")) === x && 
                    parseInt(element.getAttribute("data-y")) === y;
            });
            
            if (existingPixel) {
                if (currentColor) {
                    if (existingPixel.getAttribute("fill") !== currentColor) {
                        existingPixel.setAttribute("fill", currentColor);
                        hasDrawnPixel = true;
                    }
                } else {
                    activeLayer.removeChild(existingPixel);
                    hasDrawnPixel = true;
                }
            } else if (currentColor) {
                const newPixel = createPixelPath(x, y, currentColor);
                newPixel.setAttribute("data-x", x);
                newPixel.setAttribute("data-y", y);
                activeLayer.appendChild(newPixel);
                hasDrawnPixel = true;
            }
            
            lastDrawnPixel = { x, y };
        }

        // Bend slider event listener
        bendSlider.addEventListener('input', (e) => {
            bendAmount = parseFloat(e.target.value);
            bendValue.textContent = bendAmount.toFixed(1);
            updateAllPixels();
        });

        function updateGridPosition() {
            const container = document.getElementById('svgCanvasContainer');
            const xOffset = -viewportOffsetX % gridSize;
            const yOffset = -viewportOffsetY % gridSize;
            const gridColor = "#cccccc05";
            
            container.style.backgroundImage = `
                linear-gradient(to right, ${gridColor} 1px, transparent 1px),
                linear-gradient(to bottom, ${gridColor} 1px, transparent 1px)
            `;
            container.style.backgroundPosition = `${xOffset}px ${yOffset}px`;
            container.style.backgroundSize = `${gridSize}px ${gridSize}px`;
        }

        function drawPixel(e) {
            if (!activeLayer) return;
            
            if (e.ctrlKey && e.buttons === 1) {
                if (!isPanning) {
                    isPanning = true;
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                    return;
                }
                
                const deltaX = e.clientX - lastPanX;
                const deltaY = e.clientY - lastPanY;
                
                viewportOffsetX -= deltaX;
                viewportOffsetY -= deltaY;
                
                lastPanX = e.clientX;
                lastPanY = e.clientY;
                
                updateAllPixels()
                updateGridPosition();
                return;
            }
            
            // Normal drawing behavior
            if (isDrawing) {
                const gridPos = screenToGridCoordinates(e.clientX, e.clientY);
                drawPixelAtPosition(gridPos);
            }
        }

        // Event listeners
        addLayerButton.addEventListener('click', createLayer);

        // Mouse event listeners

        document.addEventListener('mousedown', (e) => {
            if (!e.target.closest('#svgCanvasContainer')) return;
            e.preventDefault();

            // Handle panning first, regardless of current tool
            if ((e.ctrlKey && e.buttons === 1) || e.buttons === 4) { // 4 is middle mouse button
                handlePanning(e);
                return;
            }

            if (currentTool === 'pencil') {
                isDrawing = true;
                hasDrawnPixel = false;
                const originalColor = currentColor;
                if (e.button === 2) currentColor = null;
                drawPixel(e);
                currentColor = originalColor;
            } else if (currentTool === 'select') {
                const rect = svgCanvasContainer.getBoundingClientRect();
                if (e.button === 0) { // Left click
                    if (selectedPixels.size > 0 && isPixelInSelection(e.clientX, e.clientY)) {
                        // Start dragging selection
                        isDraggingSelection = true;
                        const gridPos = screenToGridCoordinates(e.clientX, e.clientY);
                        dragOffset.x = gridPos.x;
                        dragOffset.y = gridPos.y;
                        // Store original positions
                        originalPositions.clear();
                        selectedPixels.forEach(pixel => {
                            originalPositions.set(pixel, {
                                x: parseInt(pixel.getAttribute('data-x')),
                                y: parseInt(pixel.getAttribute('data-y'))
                            });
                        });
                    } else {
                        // Reset all selection state before starting a new one
                        isSelecting = false;
                        isDraggingSelection = false;
                        selectionStart = null;
                        selectionEnd = null;
                        selectedPixels.clear();
                        originalPositions.clear();
                        selectionOverlay.style.display = 'none';
                        // Reset the overlay dimensions
                        selectionOverlay.style.width = '0';
                        selectionOverlay.style.height = '0';
                        Array.from(activeLayer.children).forEach(pixel => {
                            pixel.classList.remove('selected-pixel');
                        });
                        
                        // Now start the new selection
                        requestAnimationFrame(() => {
                            isSelecting = true;
                            selectionStart = {
                                x: e.clientX - rect.left,
                                y: e.clientY - rect.top
                            };
                            selectionEnd = selectionStart; // Initialize end to be same as start
                            selectionOverlay.style.display = 'block';
                            updateSelectionOverlay();
                        });
                    }
                }
            }
        });

        // Update the mousemove event handler for selection
        document.addEventListener('mousemove', (e) => {
            if (!e.target.closest('#svgCanvasContainer')) return;

            // Handle panning first, regardless of current tool
            if (isPanning && ((e.ctrlKey && e.buttons === 1) || e.buttons === 4)) {
                handlePanning(e);
                return;
            }

            if (currentTool === 'pencil' && isDrawing) {
                const originalColor = currentColor;
                if (e.buttons === 2) currentColor = null;
                drawPixel(e);
                currentColor = originalColor;
            } else if (currentTool === 'select') {
                if (isSelecting) {
                    const rect = svgCanvasContainer.getBoundingClientRect();
                    selectionEnd = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    updateSelectionOverlay();
                } else if (isDraggingSelection) {
                    const currentGridPos = screenToGridCoordinates(e.clientX, e.clientY);
                    const deltaX = currentGridPos.x - dragOffset.x;
                    const deltaY = currentGridPos.y - dragOffset.y;
                    
                    selectedPixels.forEach(pixel => {
                        const original = originalPositions.get(pixel);
                        const newX = original.x + deltaX;
                        const newY = original.y + deltaY;
                        updatePixelPath(pixel, newX, newY);
                        pixel.setAttribute('data-x', newX);
                        pixel.setAttribute('data-y', newY);
                    });
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            cleanupPanning();
            if (currentTool === 'pencil') {
                if (isDrawing && hasDrawnPixel) {
                    saveState();
                }
                isDrawing = false;
            } else if (currentTool === 'select') {
                if (isSelecting) {
                    isSelecting = false;
                    updateSelection();
                    // Nettoyage complet des donn√©es du rectangle de s√©lection apr√®s avoir appliqu√© la s√©lection
                    selectionOverlay.style.display = 'none';
                    selectionStart = null;
                    selectionEnd = null;
                } else if (isDraggingSelection) {
                    // Handle pixel replacement on drag end
                    selectedPixels.forEach(pixel => {
                        const x = parseInt(pixel.getAttribute('data-x'));
                        const y = parseInt(pixel.getAttribute('data-y'));
                        
                        const existingPixel = Array.from(activeLayer.children).find(element => {
                            if (element === pixel) return false;
                            return parseInt(element.getAttribute("data-x")) === x && 
                                parseInt(element.getAttribute("data-y")) === y;
                        });

                        if (existingPixel) {
                            activeLayer.removeChild(existingPixel);
                        }
                    });
                    
                    isDraggingSelection = false;
                    saveState();
                }
            }
            isPanning = false;
            lastDrawnPixel = null;
        });
        
        document.addEventListener('mouseleave', () => {
            cleanupPanning();
            if (isDrawing && hasDrawnPixel) {
                saveState();
            }
            isDrawing = false;
            isPanning = false;
            lastDrawnPixel = null;
        });

        // Touch event listeners
        svgCanvasContainer.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            return false;
        });

        svgCanvasContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            
            // Two-finger pan
                if (e.touches.length === 2) {
                    isPanningMobile = true;
                    lastTouchX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    lastTouchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    return;
                }
                
                // Single finger draw
                isDrawing = true;
                hasDrawnPixel = false;
                const position = getTouchPosition(e);
                drawPixelAtPosition(position);
        }, { passive: false });

        svgCanvasContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            // Two-finger pan
            if (e.touches.length === 2) {
                const currentTouchX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const currentTouchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                
                if (isPanningMobile) {
                    const deltaX = currentTouchX - lastTouchX;
                    const deltaY = currentTouchY - lastTouchY;
                    
                    viewportOffsetX -= deltaX;
                    viewportOffsetY -= deltaY;
                    
                    updateAllPixels()
                    updateGridPosition();
                }
                
                lastTouchX = currentTouchX;
                lastTouchY = currentTouchY;
                return;
            }
            
            // Single finger draw
            if (isDrawing) {
                const position = getTouchPosition(e);
                drawPixelAtPosition(position);
            }
        }, { passive: false });


        svgCanvasContainer.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            if (isDrawing && hasDrawnPixel) {
                saveState();
            }
            
            isDrawing = false;
            isPanningMobile = false;
            lastDrawnPixel = null;
        }, { passive: false });

        svgCanvasContainer.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            
            if (isDrawing && hasDrawnPixel) {
                saveState();
            }
            
            isDrawing = false;
            isPanningMobile = false;
            lastDrawnPixel = null;
        }, { passive: false });

        // Palette color management
        paletteColorInput.addEventListener('change', (e) => {
            const index = parseInt(e.target.getAttribute('data-index'));
            const newColor = e.target.value;
            palette[index] = newColor;
            initializePalette();
            
            // Select the changed color after initializing palette
            const newColorElement = document.querySelector(`.palette-color[data-index="${index}"]`);
            if (newColorElement) {
                document.querySelectorAll('.palette-color, .eraser-tile').forEach(el => {
                    el.classList.remove('selected');
                });
                newColorElement.classList.add('selected');
                currentColor = newColor;
                selectedPaletteIndex = index;
            }
        });

        resetPaletteButton.addEventListener('click', () => {
            palette = [...defaultPalette];
            initializePalette();
        });

        importPaletteButton.addEventListener('click', () => {
            importPaletteInput.click();
        });

        importPaletteInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(event.target.result, 'image/svg+xml');
                    const metadata = svgDoc.getElementsByTagName('metadata')[0];
                    
                    if (metadata) {
                        const importedPalette = JSON.parse(metadata.textContent);
                        if (Array.isArray(importedPalette)) {
                            palette = importedPalette;
                            initializePalette();
                        }
                    }
                } catch (error) {
                    console.error('Error importing palette:', error);
                    alert('Error importing palette. Please make sure the file is a valid palette SVG.');
                }
                importPaletteInput.value = ''; // Clear the input
            };
            reader.readAsText(file);
        });

        function importSVG(svgContent) {
            try {
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
                
                // Get all rectangles and paths from the imported SVG
                const elements = [...svgDoc.getElementsByTagName('rect'), ...svgDoc.getElementsByTagName('path')];
                
                const importLayer = createLayer();
                if (!importLayer) {
                    alert('Maximum layer limit reached. Delete a layer before importing.');
                    return;
                }

                elements
                    .sort((a, b) => {
                        const aY = parseFloat(a.getAttribute('y') || a.getAttribute('data-y'));
                        const bY = parseFloat(b.getAttribute('y') || b.getAttribute('data-y'));
                        const yDiff = aY - bY;
                        return yDiff || parseFloat(a.getAttribute('x') || a.getAttribute('data-x')) - 
                                      parseFloat(b.getAttribute('x') || b.getAttribute('data-x'));
                    })
                    .forEach(element => {
                        const x = Math.floor(parseFloat(element.getAttribute('x') || element.getAttribute('data-x')) / gridSize) * gridSize;
                        const y = Math.floor(parseFloat(element.getAttribute('y') || element.getAttribute('data-y')) / gridSize) * gridSize;
                        const fill = element.getAttribute('fill');
                        
                        const newPixel = createPixelPath(x, y, fill);
                        newPixel.setAttribute("data-x", x);
                        newPixel.setAttribute("data-y", y);
                        importLayer.svg.appendChild(newPixel);
                    });

                setActiveLayer(importLayer.id);
                saveState();
            } catch (error) {
                console.error('Error importing SVG:', error);
                alert('Error importing SVG. Please make sure the file is a valid SVG created with this tool.');
            }
        }

        // Update the import event listener
        importInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                importSVG(event.target.result);
                importInput.value = ''; // Clear the input
            };
            reader.readAsText(file);
        });

        function exportSVG() {
            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            // Find boundaries of all visible pixels
            layers.forEach(layer => {
                if (layer.visible) {
                    Array.from(layer.svg.children).forEach(pixel => {
                        const x = parseInt(pixel.getAttribute('data-x'));
                        const y = parseInt(pixel.getAttribute('data-y'));
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x + gridSize);
                        maxY = Math.max(maxY, y + gridSize);
                    });
                }
            });

            // Create export SVG with calculated size
            const exportSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            exportSvg.setAttribute("width", maxX - minX);
            exportSvg.setAttribute("height", maxY - minY);
            exportSvg.setAttribute("viewBox", `${minX} ${minY} ${maxX - minX} ${maxY - minY}`);

            layers.forEach(layer => {
                if (layer.visible) {
                    Array.from(layer.svg.children).forEach(child => {
                        exportSvg.appendChild(child.cloneNode(true));
                    });
                }
            });

            const serializer = new XMLSerializer();
            const svgBlob = new Blob([serializer.serializeToString(exportSvg)], { type: "image/svg+xml" });
            const url = URL.createObjectURL(svgBlob);

            const link = document.createElement("a");
            link.href = url;
            link.download = "pixel-art.svg";
            link.click();

            URL.revokeObjectURL(url);
        }

        // Update the event listener
        if (exportSVGBtn) {
            exportSVGBtn.addEventListener("click", exportSVG);
        }

        if (importSVGBtn) {
            importSVGBtn.addEventListener("click", () => {
                importInput.click();
            });
        }

        function saveState() {
            if (isUndoRedoAction) {
                isUndoRedoAction = false;
                return;
            }

            const state = {
                nextLayerId: nextLayerId,
                viewportOffsetX: viewportOffsetX,
                viewportOffsetY: viewportOffsetY,
                layers: layers.map(layer => ({
                    id: layer.id,
                    name: layer.name,
                    visible: layer.visible,
                    content: layer.svg.innerHTML
                }))
            };

            history = history.slice(0, currentHistoryIndex + 1);
            history.push(JSON.stringify(state));
            
            if (history.length > MAX_HISTORY) {
                history.shift();
            }
            
            currentHistoryIndex = history.length - 1;
            updateUndoRedoButtons();
        }

        function loadState(stateJson) {
            const state = JSON.parse(stateJson);
            nextLayerId = state.nextLayerId;
            viewportOffsetX = state.viewportOffsetX || 0;
            viewportOffsetY = state.viewportOffsetY || 0;
            
            // Save reference to selection overlay before clearing
            const selectionOverlay = document.getElementById('selectionOverlay');
            if (selectionOverlay) {
                selectionOverlay.remove();
            }
            
            while (svgCanvasContainer.firstChild) {
                svgCanvasContainer.removeChild(svgCanvasContainer.firstChild);
            }
            layers = [];
            
            state.layers.forEach(layerState => {
                const layer = new Layer();
                layer.id = layerState.id;
                layer.name = layerState.name;
                layer.visible = layerState.visible;
                layer.svg.innerHTML = layerState.content;
                layer.svg.style.display = layer.visible ? 'block' : 'none';
                layers.push(layer);
                svgCanvasContainer.appendChild(layer.svg);
            });
            
            // Re-append selection overlay
            if (selectionOverlay) {
                svgCanvasContainer.appendChild(selectionOverlay);
            }
            
            updateAllPixels();
            updateGridPosition();
            
            const visibleLayer = layers.find(l => l.visible);
            if (visibleLayer) {
                setActiveLayer(visibleLayer.id);
            }
            
            updateAddLayerButton();
            renderLayerPanel();
        }

        function updateUndoRedoButtons() {
            undoButton.disabled = currentHistoryIndex <= 0;
            redoButton.disabled = currentHistoryIndex >= history.length - 1;
        }

        function copySelection() {
            if (selectedPixels.size === 0) return;

            // Get the bounds of the selection
            let minX = Infinity, minY = Infinity;
            selectedPixels.forEach(pixel => {
                const x = parseInt(pixel.getAttribute('data-x'));
                const y = parseInt(pixel.getAttribute('data-y'));
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
            });

            // Store pixel data relative to top-left corner
            clipboardData = Array.from(selectedPixels).map(pixel => ({
                relativeX: parseInt(pixel.getAttribute('data-x')) - minX,
                relativeY: parseInt(pixel.getAttribute('data-y')) - minY,
                fill: pixel.getAttribute('fill')
            }));

            // Store the offset for future paste operations
            clipboardOffset = { x: minX, y: minY };
        }

        function cutSelection() {
            if (selectedPixels.size === 0) return;
            
            // Copy first
            copySelection();
            
            // Then delete
            selectedPixels.forEach(pixel => pixel.remove());
            clearSelection();
            saveState();
        }

        function pasteSelection() {
            if (!clipboardData || !activeLayer) return;

            // Clear current selection
            clearSelection();

            // Calculate paste position based on mouse position
            const rect = activeLayer.getBoundingClientRect();
            const mouseX = lastPanX || rect.left + rect.width / 2;
            const mouseY = lastPanY || rect.top + rect.height / 2;
            const gridPos = screenToGridCoordinates(mouseX, mouseY);

            // Create new pixels
            selectedPixels.clear();
            clipboardData.forEach(data => {
                const newX = gridPos.x + data.relativeX;
                const newY = gridPos.y + data.relativeY;
                
                // Remove any existing pixel at this position
                const existingPixel = Array.from(activeLayer.children).find(pixel => 
                    parseInt(pixel.getAttribute('data-x')) === newX && 
                    parseInt(pixel.getAttribute('data-y')) === newY
                );
                if (existingPixel) {
                    existingPixel.remove();
                }

                // Create new pixel
                const newPixel = createPixelPath(newX, newY, data.fill);
                newPixel.setAttribute('data-x', newX);
                newPixel.setAttribute('data-y', newY);
                activeLayer.appendChild(newPixel);
                
                // Add to selection
                selectedPixels.add(newPixel);
                newPixel.classList.add('selected-pixel');
            });

            saveState();
        }

        // Undo/Redo handlers
        undoButton.addEventListener('click', () => {
            if (currentHistoryIndex > 0) {
                isUndoRedoAction = true;
                currentHistoryIndex--;
                loadState(history[currentHistoryIndex]);
                updateUndoRedoButtons();
            }
        });

        redoButton.addEventListener('click', () => {
            if (currentHistoryIndex < history.length - 1) {
                isUndoRedoAction = true;
                currentHistoryIndex++;
                loadState(history[currentHistoryIndex]);
                updateUndoRedoButtons();
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Handle tool shortcuts
            if (e.key === 'a' || e.key === 'A') {
                currentTool = 'pencil';
                pencilToolBtn.classList.add('selected');
                selectToolBtn.classList.remove('selected');
                clearSelection();
            } else if (e.key === 'z' || e.key === 'Z') {
                currentTool = 'select';
                selectToolBtn.classList.add('selected');
                pencilToolBtn.classList.remove('selected');
            }

            // Undo/Redo (Ctrl+Z, Ctrl+Y)
            if (e.ctrlKey) {
                if (e.key === 'z' || e.key === 'Z') {
                    e.preventDefault();
                    if (e.shiftKey && currentHistoryIndex < history.length - 1) {
                        // Ctrl+Shift+Z for Redo
                        isUndoRedoAction = true;
                        currentHistoryIndex++;
                        loadState(history[currentHistoryIndex]);
                        updateUndoRedoButtons();
                    } else if (!e.shiftKey && currentHistoryIndex > 0) {
                        // Ctrl+Z for Undo
                        isUndoRedoAction = true;
                        currentHistoryIndex--;
                        loadState(history[currentHistoryIndex]);
                        updateUndoRedoButtons();
                    }
                } else if ((e.key === 'y' || e.key === 'Y') && currentHistoryIndex < history.length - 1) {
                    // Ctrl+Y for Redo
                    e.preventDefault();
                    isUndoRedoAction = true;
                    currentHistoryIndex++;
                    loadState(history[currentHistoryIndex]);
                    updateUndoRedoButtons();
                }
            }

            // Layer visibility toggle (V + number)
            if ((e.key === 'v' || e.key === 'V') && !e.ctrlKey) {
                const layerKeys = {
                    '&': 0, '√©': 1, '"': 2, "'": 3, '(': 4,
                    '1': 0, '2': 1, '3': 2, '4': 3, '5': 4
                };
                
                const handler = (key) => {
                    const index = layerKeys[key];
                    if (index !== undefined && index < layers.length) {
                        toggleLayerVisibility(layers[index].id);
                    }
                };

                // Set up one-time keypress listener for the number
                const listener = (event) => {
                    handler(event.key);
                    document.removeEventListener('keydown', listener);
                };
                document.addEventListener('keydown', listener);
            }

            // Delete/Backspace to delete selected pixels
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedPixels.size > 0) {
                e.preventDefault();
                selectedPixels.forEach(pixel => pixel.remove());
                clearSelection();
                saveState();
            }

            // Space to temporarily switch to pan tool
            if (e.key === ' ' && !isPanning) {
                e.preventDefault();
                const savedTool = currentTool;
                currentTool = 'pan';
                
                const spaceUpHandler = () => {
                    currentTool = savedTool;
                    document.removeEventListener('keyup', spaceUpHandler);
                };
                document.addEventListener('keyup', spaceUpHandler);
            }

            // ESC to clear selection
            if (e.key === 'Escape') {
                clearSelection();
            }

            // Number key shortcuts for palette colors (1-5 and special chars)
            const keyMappings = {
                '&': 0, 
                '√©': 1,
                '"': 2,
                "'": 3,
                '(': 4,
                '¬≤': 'eraser'
            };
            
            const numKey = e.key;
            const index = keyMappings[numKey] ?? parseInt(numKey) - 1;

            if ((numKey >= '1' && numKey <= '5') || numKey in keyMappings) {
                if (numKey === '¬≤') {
                    // Handle eraser
                    document.querySelectorAll('.palette-color, .eraser-tile').forEach(el => {
                        el.classList.remove('selected');
                    });
                    document.querySelector('.eraser-tile').classList.add('selected');
                    currentColor = null;
                } else if (index >= 0 && index < palette.length) {
                    // Handle color selection
                    document.querySelectorAll('.palette-color, .eraser-tile').forEach(el => {
                        el.classList.remove('selected');
                    });
                    const colorElement = document.querySelector(`.palette-color[data-index="${index}"]`);
                    if (colorElement) {
                        colorElement.classList.add('selected');
                        currentColor = palette[index];
                        selectedPaletteIndex = index;
                    }
                }
            }

            if (e.key === 'r' || e.key === 'R') {
                e.preventDefault(); // Prevent the 'r' key from being written in the input
                // Find the selected layer
                const selectedLayer = layers.find(l => l.id === activeLayerId);
                if (selectedLayer) {
                    // Create input for renaming
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = selectedLayer.name;
                    input.className = 'layer-name-input';

                    // Find the current name button
                    const nameButton = document.querySelector(`.layer-item[data-layer-id="${activeLayerId}"] .layer-name-button`);
                    if (nameButton) {
                        nameButton.replaceWith(input);
                        input.focus();
                        input.select();

                        function saveNewName() {
                            const newName = input.value.trim();
                            if (newName && newName !== selectedLayer.name) {
                                if (layers.some(l => l.id !== selectedLayer.id && l.name === newName)) {
                                    alert('A layer with this name already exists. Please choose a different name.');
                                    return;
                                }
                                selectedLayer.name = newName;
                                saveState();
                            }
                            renderLayerPanel();
                        }

                        input.addEventListener('blur', saveNewName);
                        input.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                saveNewName();
                            } else if (e.key === 'Escape') {
                                renderLayerPanel();
                            }
                        });
                    }
                }
            }
        });

        pencilToolBtn.addEventListener('click', () => {
            currentTool = 'pencil';
            pencilToolBtn.classList.add('selected');
            selectToolBtn.classList.remove('selected');
            clearSelection();
        });

        selectToolBtn.addEventListener('click', () => {
            currentTool = 'select';
            selectToolBtn.classList.add('selected');
            pencilToolBtn.classList.remove('selected');
        });

        svgCanvasContainer.addEventListener('mousedown', (e) => {
            if (e.button === 1) { // Middle mouse button
                e.preventDefault();
            }
        });

        scaleSlider.addEventListener('input', (e) => {
            pixelScale = parseFloat(e.target.value);
            scaleValue.textContent = pixelScale.toFixed(1);
            updateAllPixels();
        });

        function initializeApp() {
            initializePalette();
            initializeLayers();
            updateGridPosition();
            saveState();
        }

        initializeApp();
    </script>
</body>
</html>